\section{Syntax}

The syntax of Tyr is inspired by Scala and SKilL.


\subsection{Literals}


\begin{figure}
	\begin{grammar}
		<int> ::= ('0'-'9')+
		
		<hex> ::= ('0'-'0'|'A'-'F'|'a'-'f')+
		
		<Integer> ::= '-'? <int> ('i' <int>?)?
		
		<HexInteger> ::= "0x" <hex> ('i' <int>?)?
		
		<long> ::= '-'? <int> 'L'
		
		<Float> ::= '-'? <int>? '.' <int> (('e'|'E') '-'? <int>)? ('f' <int>?)?
		
		<string> ::= '\verb|"|' \textasciitilde['\verb|"|']* '\verb|"|'
		
		<Identifier> ::= '\verb|`|' \textasciitilde['\verb|`|']+ '\verb|`|'
	\end{grammar}
	\caption{Literals}
	\label{fig:syn:literals}
\end{figure}

\subsection{Grammar}

\subsubsection{Top Level Structure}

\begin{figure}
	\begin{grammar}
		<file> ::= ???
	\end{grammar}
	\caption{Literals}
	\label{fig:syn:top:level}
\end{figure}

\subsubsection{Members}

\subsubsection{Expressions}

- es muss simpleExpressions geben, die für typen und einfache ausdrücke verwendet wird
- es muss literalExpressions geben, die ausdrücke ohne berechnungen enthalten, wie etwa Typnamen; literalExpressions enthalten keine operatoren, sind also vor dem OperatorBinding-Schritt auswertbar
- statements sind expressions, aber keine simpleExpressions
- blöcke sind in diesem sinne wie statements
- d.h. wird eine expression erwartet kann man einen block als ({...}) unterbringen, nicht aber als {...}.

\subsection{Examples}

\begin{verbatim}
def foreach (p : BlockParameter(Any), b : Block(void)) {
  while(move()) {
	p = get();
	b();
  }
}
def forall (p : BlockParameter(Any), b : Block(bool)) : bool = {
  while(move()) {
    p = get();
    if(!b())
      return false;
  }
  return true;
}

test "usage" {
  foreach x do {
    print(x)
  }
  println(forall x do { x != null; })
}
\end{verbatim}
