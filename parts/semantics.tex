\section{Semantics}

The semantics of Tyr is loosely based on C++ and Scala.

\subsection{Types of literal Values}
\todo{sind die ints nicht in wahrheit LiteralInt?}

The type of <Integer> is \texttt{int}, if no 'i' or no number behind the 'i' is supplied.
If a number is supplied, the number will be used as argument for \texttt{Integer}(n).
If the resulting Type has a named subtype in \texttt{tyr.lang}, the subtype will be chosen.
Hence, \texttt{0i8} is a \texttt{byte} of value 0.
Also, \texttt{0}, \texttt{0i} and \texttt{0i32} are indistinguishable.

The type of <HexInteger> is UnsignedInteger(n), where n is the number supplied via 'i' defaulting to 32.

The type of <long> is \texttt{long}.

The type of <Float> is analogous to <Integer> except that it is based on \texttt{FloatingPoint}(n) and defaults to \texttt{double}.
The type is \texttt{float} if a single \texttt{f} is supplied.
This rule is designed to be compatible with common programming languages.

The type of <string> is \texttt{LiteralString}.

<Identifier> literals yield identifiers.
An identifier is neither a type nor a value.

\subsection{Unescaping of String and Identifier Literals}

Tyr uses the same escaping mechanism as Java.
Unescaping happens for <string> and <identifier> before further processing.


\subsection{Access Paths introduced by local \texttt{with}}

Any experession that yields a scope can be imported with a with.
This import results in an access path to the names imported into the local scope.
If that access has a side effect, the effect may be executed at every access to the scope.
Function with an implicit \texttt{this} parameter start with an implicit \texttt{with this;} expression.

\subsection{Scopes}

Scope access happens via the dot-Operator ('.').
Scopes form a tree.
The root is called \texttt{\_root\_}.

If a scope is imported via a \texttt{with}-clause, imported scopes are addressed before ascending into parents.
If an imported scope is evaluated, parent scopes will be followed until a scope is encountered that does not belong to a user defined entity, i.e. that is a pure namespace.
This rule ensures that importing a type makes operations from its super types visible but not from its enclosing scope.

\todo{if an import ends with an \texttt{\_all\_} then all members of the target entity will be imported}

\paragraph{Dynamic Lookup} The first lookup strategy is called dynamic lookup and is always applied first.
It searches the scope of the target entity.
The scope of a value is its static type.
The scope and its imports are queried.
If no result can be found, the super types/classes are queried recursively.
If no results can be found, the super interfaces are queried.
\todo{specify that super types are linearized in topological order to prevent distant interfaces shadowing closer interfaces; note to self: in order to keep memory complexity of this feature linear, we have to assign numbers in a single pass before looking at expressions; evluation is performed by a heap containing all unevaluated super types; the key in the heap is said number}


\paragraph{Static Lookup} If dynamic lookup failed, a static lookup is performed.
This lookup follows the scope tree, including imports done by the scope.
If this lookup fails at \texttt{\_root\_}, a single flat lookup in \texttt{tyr.lang} is performed.


\subsubsection{Overloading and Overriding}

Find a good rule for near and perfect matches and function application.
Note to self: The first call following a member access has to be evaluated before the member access!

There is a function lookup mode that applies if the member access is followed by a call or in the case of operator usage.
This mode yields a set of results. \todo{rules?}


\subsection{Types and Classes}

\subsubsection{Representation of Objects}

Rule: only conversions and instances of types with known representation are legal, i.e. there cannot be a variable/result/parameter of type Any.
Note to self: There is a backdoor using type variables?
What about p = block : Block[Any]?