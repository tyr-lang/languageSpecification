\section{Semantics}

The semantics of Tyr is loosely based on C++ and Scala.

\subsection{Types of literal Values}
\todo{sind die ints nicht in wahrheit LiteralInt?}

The type of <Integer> is \texttt{int}, if no 'i' or no number behind the 'i' is supplied.
If a number is supplied, the number will be used as argument for \texttt{Integer}(n).
If the resulting Type has a named subtype in \texttt{tyr.lang}, the subtype will be chosen.
Hence, \texttt{0i8} is a \texttt{byte} of value 0.
Also, \texttt{0}, \texttt{0i} and \texttt{0i32} are indistinguishable.

The type of <HexInteger> is UnsignedInteger(n), where n is the number supplied via 'i' defaulting to 32.

The type of <long> is \texttt{long}.

The type of <Float> is analogous to <Integer> except that it is based on \texttt{FloatingPoint}(n) and defaults to \texttt{double}.
The type is \texttt{float} if a single \texttt{f} is supplied.
This rule is designed to be compatible with common programming languages.

The type of <string> is \texttt{LiteralString}.

<Identifier> literals yield identifiers.
An identifier is neither a type nor a value.

\subsection{Unescaping of String and Identifier Literals}

Tyr uses the same escaping mechanism as Java.
Unescaping happens for <string> and <identifier> before further processing.


\subsection{Access Paths introduced by local \texttt{with}}

Any experession that yields a scope can be imported with a with.
This import results in an access path to the names imported into the local scope.
If that access has a side effect, the effect may be executed at every access to the scope.
Function with an implicit \texttt{this} parameter start with an implicit expression "\texttt{with this;}".
The last part of an import expression must be an identifier that is used to create a name in the scope that the import occurs in.

\begin{lstlisting}[language=tyr]
with tyr.lang; // legal, makes name lang accessible
with lang.int; // legal, makes tyr.lang.int accessible under name int
with 7.toString(); // illegal, last part is a method
with 7.toString().bytes; // legal, will make the bytes of the string "7" accessebile under the name bytes; note: the call will be reevaluated on each usage
with 7.type; // legal, makes tyr.lang.LiteralInt available unter the name type
with "".type; // illegal, because the name type is already used in this scope (previous import)
with "".class; // legal
\end{lstlisting}


\subsection{Scopes}

As a consequence of assigning a type to any semantic entity, any entity is a scope.

Scope access happens via the dot-Operator ('.').
The static parent relationship of scopes forms a tree.
The root is called \texttt{\_root\_}.

If a scope is imported via a \texttt{with}-clause, imported scopes are addressed before ascending into parents.
If an imported scope is evaluated, parent scopes will be followed until a scope is encountered that does not belong to a user defined entity, i.e. that is a pure namespace.
This rule ensures that importing a type makes operations from its super types visible but not from its enclosing scope.

Including inheritance, scopes form a DAG.
Imports are not transitive.
Therefore, the set of visible entities can be enumerated using recursive descent on the scope DAG.

\todo{if an import ends with an \texttt{\_all\_} then all members of the target entity will be imported}

\paragraph{Dynamic Lookup} The first lookup strategy is called dynamic lookup and is always applied first.
It searches the scope of the target entity.
The scope of a value is its static type.
The scope and its imports are queried.
If no result can be found, the super types/classes are queried recursively.
If no results can be found, the super interfaces are queried.
\todo{specify that super types are linearized in topological order to prevent distant interfaces shadowing closer interfaces; note to self: in order to keep memory complexity of this feature linear, we have to assign numbers in a single pass before looking at expressions; evluation is performed by a heap containing all unevaluated super types; the key in the heap is said number}


\paragraph{Static Lookup} If dynamic lookup failed, a static lookup is performed.
This lookup follows the scope tree, including imports done by the scope.
If this lookup fails at \texttt{\_root\_}, a single flat lookup in \texttt{tyr.lang} is performed.


\subsubsection{Namespaces}

There is only one namespace for all kinds of named entities.
In a lookup, fields count like parameterless methods.


\subsubsection{Overloading and Overriding}

Find a good rule for near and perfect matches and function application.
Note to self: The first call following a member access has to be evaluated before the member access!

There is a function lookup mode that applies if the member access is followed by a call or in the case of operator usage.
This mode yields a set of results. \todo{rules?}
The evaluation of a member access in a simple expression yields a distance ordered non-empty sequence of results.
Parameterless entities are at the first position.
Only one parameterless entity will be presented, as it will shadow any other entity anyway.
If the user of the member access expects a single entry, the first element of that sequence is chosen.
Otherwise a matching element can be picked.

\todo{E-O-E-Regel gegen unary operators}

\todo{Single result? Implicit conversions?}

\begin{lstlisting}[language=tyr]
- 7 == -7;
int.`-`(7) == -7;
int.`-` 7 == -7;  // name resolution error?
\end{lstlisting}


\subsection{Types and Classes}

\subsubsection{Representation of Objects}

Rule: only conversions and instances of types with known representation are legal, i.e. there cannot be a variable/result/parameter of type Any.
Note to self: There is a backdoor using type variables?
What about p = block : Block[Any]?

\subsubsection{Static and Dynamic Type of an Expression}

The static type of an expression can be accessed via the field \texttt{type}.
The dynamic type of an expression can be accessed via the field \texttt{class}.
The dynamic type is only available for Objects.
In a type safe program, the statement $\forall x. x\texttt{.class} <: x\texttt{.type}$ is true.
For the sake of symmetry, expressions argument to an access of \texttt{type} will be evaluated.

\subsection{Tests}

Tests are methods in a class that have no surrounding instance, i.e. static methods.
They have no name and will not be exported to other modules or to runnable programms.
Tests can violate arbitrary visibility rules to simplify test code.